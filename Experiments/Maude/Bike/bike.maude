*** Specification of BIKE
*** Author: Víctor García Valero <vicgarval@upv.es>

*** Module specifying basic datatypes and its operations used in BIKE
fmod DATA-TYPES is
    protecting NAT .

    *** Supersort of all data
    sort Data . 
    *** Definition of type polynomial for our data
    *** Definition of type polynomial without identity element to avoid collision problem
    sorts Polynomial .

    *** Specify that polynomials are data
    subsorts Polynomial < Data .

    subsort Nat < Polynomial .

    vars P0 P1 P2 : Polynomial .
    
    *** Operator addition of polynomials
    op _p+_ : Polynomial Polynomial -> Polynomial [assoc comm prec 33] .
    *** Identity axiom as an equation to avoid colapsing
    eq 0 p+ P0 = P0 .

    *** Operator multiplication of polynomials
    op _p*_ : Polynomial Polynomial -> Polynomial [assoc comm prec 31] .
    *** Identity axiom as an equation to avoid colapsing
    eq 1 p* P0 = P0 .

    *** Distributive property of polynomial product over polynomial addition
    eq (P0 p+ P1) p* P2 = (P0 p* P2) p+ (P1 p* P2) .

    *** Pair
    sort Pair .

    *** A Pair can be seen as a Polynomial divided in two parts
    subsort Pair < Polynomial .

    op [_,_] : Data Data -> Pair [ctor] .

    vars D1 D2 : Data .

    *** First element of Pair
    op first : Pair -> Data .
    eq first([D1,D2]) = D1 .
    *** Second element of Pair
    op second : Pair -> Data .
    eq second([D1,D2]) = D2 .

    *** Inverse operation over polynomials
    op inv : Polynomial -> Polynomial .

    eq P0 p* inv(P0) = 1 .
endfm

*** Module to specify all the hash functions that are used in the steps of BIKE KEM
fmod BIKE-HASH-OPERATIONS is
    protecting DATA-TYPES .

    *** H recieves a random polynomial and returns a hash of it (which is a pair of polynomials)
    op H : Polynomial -> Pair [ctor] .
    op K : Polynomial Pair -> Polynomial [ctor] .
    op L : Polynomial -> Polynomial [ctor] .

    vars P0 P1 : Polynomial .

    *** Possible relation on how the concatenation for the computation of L is done
    *** This possibility considers the case when the concatenation is doen throug addition
    eq L([P0,P1]) = L(P0 p+ P1) .
endfm

*** Module to represent the data and operations handled during KEYGEN
fmod BIKE-KEYGEN is
    protecting DATA-TYPES .

    *** Constant value representing the h_i sampled from the private key space H_w
    ops h0 h1 h0' h1' : -> Polynomial .

    *** Constant value representing the sigma obtained in step 3
    ops sigma sigma' : -> Polynomial .
endfm

*** Module to represent the operations and data handled during ENC
fmod BIKE-ENC is
    protecting DATA-TYPES .
    protecting BIKE-HASH-OPERATIONS .

    *** Messages randomply generated by a principal
    ops m1 m2 : -> Polynomial .

    *** Errors generated from H(M1)
    ops e0 e1 : -> Polynomial .
    eq H(m1) = [e0,e1] .

    *** Errors generated from H(M2)
    ops e0' e1' : -> Polynomial .
    eq H(m2) = [e0',e1'] .

    *** Operator to represent the shared key
    ops k k' : -> Polynomial .
    var C : Pair .
    *** Key generated from K(m1,c)
    eq K(m1,C) = k .
    *** Key generated from K(m2,c)
    eq K(m2,C) = k' .
endfm

*** Module to represent the operations and data handled during DEC
*** Its main purpouse is to demonstrate that the computed key is
*** the one that was computed in the other side using PK and C
fmod BIKE-DEC is
    protecting DATA-TYPES .
    protecting NAT .

    *** Operator to represent the decoder used (Black-Gray-Flip)
    op decoder : Polynomial Polynomial Polynomial -> Pair .
    
    vars P0 P1 P2 P3 : Polynomial .

    *** We only consider the perfect case where the obtained errors are the originals
    eq decoder((P0 p* P1) p+ (P2 p* P3), P1, P3) = [P0,P2] .

    subsort Nat < Data .

    var D : Data .

    *** XOR
    op _xorD_ : Data Data -> Data [assoc comm] .
    eq D xorD 0 = D .
    eq D xorD D = 0 .
endfm

*** Specification of the system upon BIKE will work
fmod MODEL-CONFIGURATION is
    protecting DATA-TYPES .

    ***
    *** SORTS
    ***

    sorts Identifier Content Participant Participants . 
    sorts MsgState Msg Msgs .
    subsort Msg < Msgs .
    subsort Participant < Participants .

    sorts Key Keys .
    subsort Key < Keys .

    *** We distinguish between public and secret keys, both being keys in the end
    sorts PKey SKey .

    ***We define keys as a type of content
    subsorts Polynomial < PKey SKey < Key < Content .

    *** We also declare that a pair is content
    subsort Pair < Content .

    *** Sort for the State of our system
    sort GlobalState .
    
    ***
    *** OPERATORS
    ***

    *** Empty group of keys
    op emptyK : -> Keys .
    *** Group of keys
    op _;_ : Keys Keys -> Keys [assoc comm id: emptyK] .

    var K : Key .
    vars KS1 KS2 : Keys .

    *** Operation to check the precence of a key in a participant
    op _in_ : Key Keys -> Bool .
    eq K in (KS1 ; K ; KS2) = true .
    eq K in (KS1) = false [owise] .

    *** Operator to represent the relation of a public key and a principal
    op publicKey : Identifier Key -> PKey .

    *** Operator to represent the relation of a secret key and a principal
    op secretKey : Identifier Key -> SKey .

    *** Operator to represent the shared key with a participant
    op sharedKey : Identifier Key -> SKey [format (g! o)] .

    *** Posible states for a message delivering PK
    ops sentPK receivedPK : -> MsgState .
    *** Posible states for a message delivering C
    ops sentC receivedC : -> MsgState .

    *** Empty content
    op emptyC : -> Content .
    *** Group of contents
    op __ : Content Content -> Content [assoc comm id: emptyC] .

    vars C CONT1 CONT2 : Content .

    *** Operation to check the contents of a participant
    op _in_ : Content Content -> Bool .
    eq C in (CONT1 C CONT2) = true .
    eq C in (CONT1) = false [owise] .

    *** Structure of a message
    *** Sender, Receiver, State, Content
    op msg{(_,_)[_]_} : Identifier Identifier MsgState Content -> Msg .

    *** Group of messsages
    op emptyM : -> Msgs .
    op __ : Msgs Msgs -> Msgs [assoc id: emptyM format (d nt d)] .

    var M : Msg .
    vars MS1 MS2 : Msgs .
    
    *** Operation to check the network
    op _in_ : Msg Msgs -> Bool .

    eq M in (MS1 M MS2) = true .
    eq M in (MS1) = false [owise] .

    *** Defintion of our three main participants followiing the literature
    ops Alice Eve Bob : ->  Identifier [ctor] .

    *** Definition of the default participant
    op none : -> Identifier [ctor] .

    *** Operator to assign a Ciphered text to a participant
    op cI : Identifier Pair -> Content .

    *** Operator to mark the current participant to whom the key exchange is happening
    op peer : Identifier -> Content .

    *** Definition of the components of a Participant
    *** (idenifier [keys] content)
    op _[_]_ : Identifier Keys Content -> Participant [ctor] .

    *** Group of participants
    op __ : Participant Participant -> Participants [assoc comm format (d n d)] .

    *** Global state composed by Samples, Participants and a Network with messages
    op {_}<_>net(_) : Content Participants Msgs -> GlobalState [ctor format (n d d n n n d d d d)] .
endfm

*** Protocol/mechanism samples and behaviour
mod BIKE is
    ***
    *** IMPORTS
    ***

    protecting DATA-TYPES .
    protecting BIKE-HASH-OPERATIONS .
    protecting BIKE-KEYGEN .
    protecting BIKE-ENC .
    protecting BIKE-DEC .
    protecting MODEL-CONFIGURATION .

    *** Group of polynomials sigma that can be sampled
    op sigmas : Content -> Content .

    *** Group of messages m that can be sampled
    op ms : Content -> Content .

    *** Group of polynomials h that can be sampled; They come in pairs
    op hs : Content -> Content .

    *** Operator to assign a polynomial 'sigma' to a participant
    op sigmaI : Identifier Polynomial -> Content .

    *** Operator to assign a message to a participant
    op mI : Identifier Polynomial -> Content .

    *** Operator to assign a random pair of hs to a participant
    op hI : Identifier Pair -> Content .

    ***
    *** INITIAL STATES
    ***
    ops init1 init2 : -> GlobalState .
    eq init1 = {sigmas(sigma) ms(m1) hs([h0,h1])} < (Alice[emptyK]peer(none)) (Eve[emptyK]peer(none)) (Bob[emptyK]peer(none)) >net(emptyM) .
    eq init2 = {sigmas(sigma sigma') ms(m1 m2) hs([h0,h1] [h0',h1'])} < (Alice[emptyK]peer(none)) (Eve[emptyK]peer(none)) (Bob[emptyK]peer(none)) >net(emptyM) .

    ***
    *** RULES
    ***

    vars ID1 ID2 ID3 : Identifier .
    var PS : Participants .
    vars MSGS MSGS' : Msgs .
    vars SK SK' : SKey .
    vars PK PK' : PKey .
    vars Cs Cs' Hs Es : Pair .
    vars C0 C1 : Polynomial .
    vars E0 E1 : Polynomial .
    var M : Polynomial .
    vars KS1 KS2 KS3 : Keys .
    vars SAM1 SAM2 : Data .
    vars CONT1 CONT2 CONT3 : Content .

    ***
    *** HONEST PARTICIPANT BEHAVIOUR
    ***

    *** For now the protocol only starts when the participant can sample necesary values for keygen

    crl [KeyGen] :  {sigmas(SAM1 CONT1) hs(SAM2 CONT2) CONT3} < (ID1[emptyK]peer(none)) PS >net(MSGS) 
                    => 
                    {sigmas(CONT1) hs(CONT2) CONT3} < (ID1[publicKey(ID1, PK)]peer(none) sigmaI(ID1,SAM1) hI(ID1, SAM2)) PS >net(MSGS) 
                    if PK := (second(SAM2) p* inv(first(SAM2))) .

    --- The public key is sent
    crl [SendPK] :  {CONT3} < (ID1[publicKey(ID1, PK) ; KS1]peer(none) CONT1) (ID2[KS2]peer(none) CONT2) PS >net(MSGS)
                    =>
                    {CONT3} < (ID1[KS1]peer(ID2) CONT1) (ID2[KS2]peer(none) CONT2) PS >net(MSGS msg{(ID1, ID2)[sentPK](PK)})
                    if  (msg{(ID1,ID2)[sentPK]PK}) in MSGS == false /\
                        (msg{(ID1,ID2)[receivedPK]PK}) in MSGS == false .

    rl [ReceivePK] :    {CONT3} < (ID2[KS2]peer(none) CONT2) PS >net(MSGS msg{(ID1, ID2)[sentPK](PK)} MSGS')
                        =>
                        {CONT3} < (ID2[publicKey(ID1, PK) ; KS2]peer(ID1) CONT2) PS >net(MSGS msg{(ID1, ID2)[receivedPK](PK)} MSGS') .
    
    *** The public key is consumed to generate a shared key
    crl [Enc] : {ms(SAM1 CONT1) CONT3} < (ID2[publicKey(ID1, PK) ; KS2]peer(ID1) CONT2) PS >net(MSGS)
                =>
                {ms(CONT1) CONT3} < (ID2[sharedKey(ID1, SK) ; KS2]peer(ID1) mI(ID2, SAM1) cI(ID1, Cs) CONT2) PS >net(MSGS)
                if  ID1 =/= ID2 /\
                    Es := H(SAM1) /\
                    E0 := first(Es) /\
                    E1 := second(Es) /\
                    Cs := [(E0 p+ (E1 p* (PK))), (SAM1 xorD L(Es))] /\
                    SK := K(SAM1, Cs) .

    *** The ciphered text is sent
    crl [SendCiph] :    {CONT3} < (ID2[KS2 ; sharedKey(ID1, SK)] peer(ID1) cI(ID1, Cs) CONT2) PS >net(MSGS)
                        =>
                        {CONT3} < (ID2[KS2 ; sharedKey(ID1, SK)] peer(none) CONT2) PS >net(MSGS msg{(ID2, ID1)[sentC](Cs)}) 
                        if  ID1 =/= ID2 /\
                            (msg{(ID2, ID1)[sentC](Cs)}) in MSGS == false /\ 
                            (msg{(ID2, ID1)[receivedC](Cs)}) in MSGS == false .
    
    rl [ReceiveCiph] :  {CONT3} < (ID1[KS1]peer(ID2) CONT1) PS >net(MSGS msg{(ID2, ID1)[sentC](Cs)} MSGS') 
                        =>
                        {CONT3} < (ID1[KS1]peer(ID2) cI(ID1, Cs) CONT1) PS >net(MSGS msg{(ID2, ID1)[receivedC](Cs)} MSGS')  .

    *** The ciphered text is consumed to generate the shared key
    crl [Dec] :  {CONT3}< (ID1[KS1] peer(ID2) hI(ID1, Hs) cI(ID1, Cs) CONT1) PS >net(MSGS)
                =>
                {CONT3}< (ID1[sharedKey(ID2, SK) ; KS1] peer(none) hI(ID1, Hs) CONT1) PS >net(MSGS) 
                if  ID1 =/= ID2 /\
                    ID2 =/= none /\
                    Es := decoder(first(Cs) p* first(Hs), first(Hs), second(Hs)) /\
                    E0 := first(Es) /\
                    E1 := second(Es) /\
                    M := second(Cs) xorD L(Es) /\
                    SK := K(M, Cs) .

    ***
    *** INTRUDER BEHAVIOUR
    ***

    crl [Intercept1] :  {CONT3}< (Eve[publicKey(Eve, PK') ; KS1]peer(none) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentPK](PK)}) 
                        =>
                        {CONT3}< (Eve[publicKey(ID1,PK) ; KS1]peer(ID1) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentPK](PK')}) 
                        if  ID1 =/= Eve /\
                            ID2 =/= Eve /\
                            ID1 =/= ID2 /\
                            PK =/= PK' /\
                            (publicKey(ID1,PK)) in KS1 == false .

    crl [Intercept2] :  {CONT3}< (Eve[KS1]cI(ID2,Cs') peer(ID2) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentC](Cs)}) 
                        =>
                        {CONT3}< (Eve[KS1]cI(Eve,Cs) peer(ID1) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentC](Cs')}) 
                        if  ID1 =/= Eve /\
                            ID2 =/= Eve /\
                            ID1 =/= ID2 /\
                            Cs =/= Cs' /\
                            (cI(ID1,Cs)) in CONT1 == false .

    crl [Step1-IdentityAttack] :    {CONT3}< (Eve[KS1]CONT1) PS >net(MSGS msg{(Alice,Bob)[sentPK](PK)})
                                    =>
                                    {CONT3}< (Eve[publicKey(Alice,PK) ; KS1]CONT1) PS >net(MSGS msg{(Alice,Bob)[sentPK](1)})
                                    if PK =/= 1 .

    crl [Step2-IdentityAttack] :    {CONT3}< (Eve[KS1]CONT1) PS >net(MSGS msg{(Bob,Alice)[sentC](Cs)})
                                    =>
                                    {CONT3}< (Eve[sharedKey(Bob, SK) ; KS1]CONT1) PS >net(MSGS msg{(Bob,Alice)[receivedC](Cs)}) 
                                    if  M := (second(Cs)) xorD L(first(Cs)) /\
                                        SK := K(M,Cs) .
endm